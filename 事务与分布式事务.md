事务

```
本地事务 
分布式事务
		在分布式系统中也要达到ACID ,这就叫分布式事务
```

### 事务

有四个特性，简称为ACID特性

**原子性（Atomicity)** : 事务作为一个整体执行，要么全部执行，要么全部不执行

**一致性(Consistency)**：确保数据库状态从一个一直状态变成另一个状态。一致状态指数据库中的而数据应满足完整性约束

**隔离性(Isolation)**：多个事务并发时，一个事务不影响到另一个事务执行

**持久性(Durability)**：已提交的事务对数据库的修改永久保存在数据库中。事务结束时，此操作不可逆转



CAP理论

```:
C:数据一致性
A:系统可用性
P:分区容错性
```

一般认为在分布式系统中，这三点不能同时满足

同时P需要优先满足，所以就只有CP AP

数据一致性   就是系统数据要同步，例如A-100,B就要同时+100

系统可用性   通俗来说就是系统不宕机，解决方法就是加集群

分区容错性   就是断网了也能用

```
eg:   AB之间断网了，断了网就不能保证数据一致性，所以三者只能满足其二。

如果AB断网了，就把AB同时锁住，谁也不能访问，这样就保证了数据一致性
```



### 隔离性

隔离的四个级别

```
读已提交:事务A事先读取了数据，事务B紧接着更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变

读未提交: 就是说事务B读取到了事务A未提交的数据

可重复读:可重复读取是指在一个事务内，多次读同一个数据，在这个事务还没结束时，其他事务不能访问该数据(包括了读写)，这样就可以在同一个事务内两次读到的数据是一样的,但是不能写事务

可串行化：事务只能一个接着一个地执行，但不能并发执行。性能低最安全。
```

脏读解决：只允许你读取我提交后的数据，我写的时候，把整个表锁住，不让你读。

不可重复读，解决：我读数据的时候，这行数据锁住，不让写。
读数据，你添加、删除数据并提交，我这边数据条数增加、减少

幻读解决：我读数据的时候，整个表锁住，不让添加、删除数据。





### 分布式事务

分布式事务解决方案有三种

1.XA 两段提交

2.TCC三段提交

3.MQ



**XA**

分两阶段实现

+ 准备阶段：首先先执行各个业务代码，执行到commit之前
+ 提交回滚阶段 如果都成功，就在数据库执行commit，如果有一个失败就全部失败，全部回滚

```
 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域，
 牺牲了可用性，对性能影响较大，不适合高并发高性能场景.
```



**TCC**

分三阶段实现 

try           预留资源提交设置的数据

confirm   提交资源，清理设置的数据

cancel	回滚，补偿原本不应该提交的 数据

```
 数据的弱一致性，性能好，try confirm cancel 都需要我们程序员自己实现相关的逻辑,比较麻烦，与具体的数据持久层无关。业务耦合度高，对业务的侵入性要强。还要保证幂等。（无论重试 调用多少次，和调用一次的结果是一样的）
```

TCC与XA不同之处在于： TCC在小明的提交 转账和小红的接受转账时分开的，TCC不像XA一样会等待其他人的状态，因此性能会好一些。





**MQ**

本地消息表，将分布式事务拆分成本地事务进行处理。

小明转账给小红，小红花先表面通知收到钱了，消息的状态修改为已收款，但是本地的数据库还没有改变，

吃此时小明把转账消息发给MQ，MQ给小红读取，此时小红的数据库才改变了。



再来一个定时任务，扫描未成功处理的消息，如果有问题就有人去处理



通过MQ达到最终一致性，性能也是最好的，只能用在支持数据最终一次性的场景



**SEATA**

Seata集合了XA 和 TCC的优点，seata是分布式事务框架

1. 对业务无侵入  有个日志表实现自动回滚，自动提交
2. 高性能  加锁，锁在commit之前

提供了一个AT模式，基于支持本地ACID事务的关系型数据库

AT模式有三个角色

+ Transaction Coordinator 事务协调器：维护全局事务的运行状态，负责协调并驱动全局事务的提或回滚
+ Transaction Manager 控制全局事务的边界，负责开启一个全局事务，并最终大气全局提交或回滚的协议
+ Resource Manager 控制分支事务，驱动分支（本地）事务的提交和回滚