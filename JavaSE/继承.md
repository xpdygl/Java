## 继承

现实生活中，继承通常指的是后人继承前人遗留的财产。而在编程语言中，继承指的是子类继承了父类的属性和行为。

现在，要编写以下两个类
    人类
        属性：姓名、年龄
        行为：吃饭、睡觉
    学生类
        属性：姓名、年龄
        行为：吃饭、睡觉、学习

我们发现，人类和学生类有一部分属性和行为是相同的，如果在两个类中都编写这些成员，代码就冗余了。

继承，就是用于解决此类问题。使用继承，能够 提升代码的复用性，减少代码冗余。



___

继承，描述的是类与类之间的关系，一个类要继承另一个类，必须符合 is-a 的关系。

### 语法格式

```java
public class 父类{
  
}

public class 子类 extends 父类{
  
}
```

​    学生类
​        属性：姓名、年龄
​        行为：吃饭、睡觉
​    老师类
​        属性：姓名、年龄、薪水
​        行为：吃饭、睡觉、授课
​    班主任类
​        属性：姓名、年龄、薪水
​        行为：吃饭、睡觉、管理

学生类、老师类和班主任类，他们之间没有谁属于谁的关系，但他们都属于人类，那么我们可以抽象出一个他们共有的父类，即人类。
将他们共有的属性和行为定义在人类中，然后继承人类即可。继承人类之后，人类中共有的属性和行为无需再次定义，只需要在各自的类中定义自己特有的属性和行为。

## 子类不能继承的内容

子类不能继承父类的构造方法，因为__构造方法要求必须和类名相同__，如果子类继承了父类的构造方法，就违反了规则。

值得注意的是，父类中的私有成员也可以被子类继承，只是子类无法直接访问，但可以通过父类的 getter & setter 方法间接访问。





## 继承后成员变量的访问

当变量名不相同时，访问没有影响，

当同名时遵守__就近原则__，优先访问子类的变量

+ 如果想访问父类的变量就要用到super关键字。super代表对父类对象的引用。

+ 如果想访问自己的变量可以用this关键字

  ### 成员方法重名

  重名的时候通过访问子类对象，只能访问到自己的成员方法。





## 方法重写

方法重写，指的是在子父类中出现了__相同的方法（返回值类型、方法名和形参都相同）__，会出现覆盖效果，即子类方法覆盖了父类的方法。

方法重写的作用
    子类继承父类后，如果子类觉得从父类继承的方法无法满足自己的需求，可以自己写一个一模一样的方法来覆盖父类的方法。

子类的功能一般都比父类强大。

子父类成员方法的签名完全相同时，子类方法会覆盖父类的方法，这种机制被称之为方法重写。





## @Override 注解

Override 的作用是检查方法是否正确重写。让编译器自动检查是否正确重写，如果不符合规范就会编译失败。

```java
class Animal {
  public void eat() {
    System.out.println("吃饭...");
  }
}
class Cat extends Animal {
     @Override
		 public void eat() {
     	System.out.println("猫吃鱼...");
 	 }
}
```

```java
class Animal {  

public void eat() {


  System.out.println("吃饭...");
}
}
class Cat extends Animal {
  @Override
  public void eat() {
    System.out.println("猫吃鱼...");
  }
}
```







## 继承后构造方法的访问

首先，构造方法的作用是在创建对象的同时初始化对象的成员变量。



在继承关系中，子类的成员变量可以通过子类自己的构造方法进行初始化，而从父类继承下来的成员变量则可以通过调用父类的构造方法进行初始化。



__任何类的任何构造方法，第一行都隐含一行 super() 代码，作用是调用父类的 空参构造方法 来初始化父类中的数据。我们也可以手动的写出来，并通过 传递参数 来调用父类的 有参构造方法。__



需要注意的是，调用__父类构造方法的代码只能写在第一行，并且，手动写了 super(参数…) 后，隐含的 super() 就没有了。__

如果要在构造方法中调用自己其他的构造方法，可以使用 this(参数…) 去调用。

需要注意的是，__this() 也必须写在构造方法第一行，并且 super() 和 this() 只能二选一__.



无论是调用父类的构造方法，还是调用自己的构造方法，__父类数据的初始化永远优先于子类。__



##  单继承

Java 语言只支持单继承，不支持多继承。



一个类只能有一个父类（一个人只能有一个父亲）



一个类可以有多个子类（一个人可以有多个儿子）



支持多层继承（一个爹可以有多个儿子



如果一个类没有继承任何的类，那么它默认继承了 Object 类。（换句话说，java里所有的类都是Objectd的子类。

___

## 抽象类

### 抽象类和抽象方法概述

在某些特定的情况下，一个父类中的方法被它所有的子类都重写了，因为它的子类都有自己的特定实现，那么，这个父类方法中的代码就是去了意义。

虽然父类方法中的代码失去了意义，但方法的签名仍然有用，__作用是规范子类的方法签名__。即使所有子类都重写了父类的方法，这些子类的方法签名仍然和父类方法签名是一致的（方法重写规范）。

既然父类方法中的代码已经失去了意义，那么，我们是否可以只要方法签名，而不要方法体呢？

Java 允许一个方法只有方法的签名而没有方法体，这种方法被称为 抽象方法，但抽象方法只能写在 抽象类 中，这意味着，包含了抽象方法的类，必须是一个抽象类！



抽象方法的作用是让子类必须重写这个方法，并且方法签名和父类签名是一致的。



__只有方法签名，没有方法的方法叫抽象方法，但抽象方法必须要写在抽象类中。__

抽象类可以没有抽象方法，但是有抽象方法的一定是抽象类



## 抽象类和抽象方法的定义和使用

定义抽象类和抽象方法都是使用 __abstract__ 关键字。

```java
public abstract class 类名 {
  //成员变量
  //构造方法    
  //成员方法    
  //抽象方法    
  public abstract 返回值类型 方法名(形参列表 ...);
}

```

+ 抽象类不能创建对象！

   + 由于抽象方法没有方法体，子类在继承抽象父类后，必须将抽象父类中所有的抽象方法全部重写。

     

     需求：定义动物类，包含一个抽象的吃饭方法。再定义猫类和狗类去继承动物类

定义一个动物类的抽象吃饭方法，让猫类和狗类必须重写吃饭，让他们有自己吃饭的方式。



抽象类不能创建对象
    抽象类中可能包含没有方法体的抽象方法，调用抽象方法是没有意义的，所以不允许创建抽象类的对象，避免通过对象调用抽象方法。

抽象类可以有构造方法
    抽象类的构造方法是提供给子类使用的，因为抽象类中仍然可以定义成员变量，子类可以通过抽象类中的构造方法初始化抽象类中的成员变量。

抽象类中可以没有抽象方法，但有抽象方法的类一定是抽象类
    不包含抽象方法的抽象类，唯一的目的就是禁止外界创建该类的对象，通常用于某些特殊的结构设计。

抽象类的子类必须重写抽象类中的所有抽象方法，除非这个子类也是抽象类
    一个类继承了抽象类，那么必须重写抽象类中的抽象方法，因为抽象方法没有方法体，必须重写后再执行才有意义。如果子类也是一个抽象类，那么可以不重写父类中的抽象方法。

## 抽象类的意义



抽象类存在的意义就是给子类继承，否则抽象类将毫无意义。抽象类体现的是一种模板思想。

模板思想的意思是，父类只定义通用的实现，无法确定的内容则定义成抽象方法，交给子类去做具体的实现。





## 模板设计模式

什么是设计模式？
    设计模式是面向对象程序设计中一些通用问题的最佳解决方案。



什么是模板设计模式？
    模板设计模式是设计模式中的一种，主要用于解决这样的一类问题：
    某个事件的处理流程是确定的，但在特定的环境下，事件处理流程中的某些步骤会有不同的表现。



定义新司机和老司机类，新司机和老司机的开车流程都是相同的，区别在于它们的驾驶姿势。

新司机
    开门、点火、双手紧握方向盘、刹车、熄火

老司机
   开门、点火、右手握方向盘左手抽烟、刹车、熄火



模板设计模式的优势就是定义了通用的框架，__特定的实现可以延迟到子类实现。__



## final关键字

 修饰类，被修饰的类不能被其他类继承

​		例如 String这个类就是被final修饰的，我们不能继承这个类。

修饰方法

​		被修饰的方法不能被子类重写

修饰变量

​		成员变量：

​			1、直接初始化

​			2、在构造方法里赋值

​		局部变量

​				基本类型：不能重新赋值

​				引用类型：不能指向一个新的对象



### 常量

被 final 修饰的变量称为 常量，常量的命名规范为所有单词的字母都是大写，单词与单词之间用下划线分隔。

```java
//常量的命名规范
private final int MAX_VALUE = 100;

```

